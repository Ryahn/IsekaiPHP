#!/usr/bin/env php
<?php

/**
 * IsekaiPHP Artisan CLI
 *
 * This command-line tool is inspired by Laravel's Artisan CLI.
 * It provides a simple, elegant interface for common development tasks.
 *
 * @see https://laravel.com/docs/artisan Laravel Artisan Documentation
 */

$autoloadPath = __DIR__ . '/vendor/autoload.php';
if (!file_exists($autoloadPath)) {
    echo "Error: Composer dependencies not installed.\n";
    echo "Please run 'composer install' to install dependencies.\n";
    exit(1);
}

require_once $autoloadPath;
require_once __DIR__ . '/src/Core/helpers.php';

use IsekaiPHP\Core\Config;
use IsekaiPHP\Database\DatabaseManager;
use Illuminate\Database\Capsule\Manager as Capsule;

if ($argc < 2) {
    echo "IsekaiPHP Artisan CLI\n";
    echo "Inspired by Laravel Artisan\n\n";
    echo "Usage: php isekai <command> [options]\n\n";
    echo "Available commands:\n";
    echo "  key:generate                    - Generate application key\n";
    echo "  migrate                         - Run database migrations\n";
    echo "  migrate:fresh                   - Drop all tables and re-run migrations\n";
    echo "  db:backup [options]              - Backup the database\n";
    echo "    Options: --file=, --max=N, --tables=table1,table2, --compression=zip|tar, --docker\n";
    echo "  db:seed [class]                  - Run database seeds (all or specific class)\n";
    echo "  serve [--host=] [--port=]       - Start the development server\n\n";
    echo "  make:controller <name> [options] - Create a new controller class\n";
    echo "    Options: -m (model), -d (migration), --model=NAME, --migration=NAME\n";
    echo "  make:model <name> [options]      - Create a new Eloquent model class\n";
    echo "    Options: -c (controller), -m (migration), --controller=NAME, --migration=NAME\n";
    echo "  make:middleware <name>          - Create a new middleware class\n";
    echo "  make:migration <name>           - Create a new migration file\n";
    echo "  make:request <name>             - Create a new form request class\n";
    echo "  make:event <name>               - Create a new event class\n";
    echo "  make:listener <name> [--event=] - Create a new event listener class\n";
    echo "  make:seed <name>                - Create a new database seed class\n\n";
    echo "  module:make <name>              - Create a new module\n";
    echo "  module:list                     - List all modules\n";
    echo "  module:enable <name>             - Enable a module\n";
    echo "  module:disable <name>            - Disable a module\n";
    echo "  module:install <name>           - Install module's Composer dependencies\n";
    echo "  module:install-all               - Install dependencies for all modules\n";
    echo "  module:publish <name> [--force]  - Publish module assets to public directory\n";
    echo "  module:publish-all [--force]     - Publish assets for all modules\n\n";
    echo "  cache:clear                     - Clear application cache\n";
    echo "  route:list                      - List all registered routes\n";
    exit(1);
}

$command = $argv[1];

// Bootstrap application for database commands
function bootstrapApp() {
    $basePath = __DIR__;
    Config::load($basePath);
    $dbConfig = Config::get('database');
    if ($dbConfig) {
        DatabaseManager::initialize($dbConfig);
    }
}

if ($command === 'key:generate') {
    $key = 'base64:' . base64_encode(random_bytes(32));
    
    echo "Application key generated:\n";
    echo $key . "\n\n";
    echo "Add this to your .env file:\n";
    echo "APP_KEY={$key}\n";
    
    // Check if .env exists and offer to update it
    if (file_exists('.env')) {
        $envContent = file_get_contents('.env');
        if (strpos($envContent, 'APP_KEY=') === false) {
            file_put_contents('.env', "\nAPP_KEY={$key}\n", FILE_APPEND);
            echo "\n✓ Added to .env file\n";
        } else {
            $newEnvContent = preg_replace('/^APP_KEY=.*/m', "APP_KEY={$key}", $envContent);
            file_put_contents('.env', $newEnvContent);
            echo "\n✓ Updated .env file\n";
        }
    }
} elseif ($command === 'migrate' || $command === 'migrate:fresh') {
    bootstrapApp();
    
    $migrationsPath = __DIR__ . '/database/migrations';
    
    if (!is_dir($migrationsPath)) {
        echo "Error: Migrations directory not found\n";
        exit(1);
    }
    
    // Create migrations table if it doesn't exist
    if (!Capsule::schema()->hasTable('migrations')) {
        Capsule::schema()->create('migrations', function ($table) {
            $table->string('migration');
            $table->integer('batch');
        });
    }
    
    // Get all migration files from main migrations directory
    $migrationFiles = glob($migrationsPath . '/*.php');
    
    // Get migration files from modules
    $modulesPath = __DIR__ . '/modules';
    if (is_dir($modulesPath)) {
        $moduleDirs = array_filter(glob($modulesPath . '/*'), 'is_dir');
        foreach ($moduleDirs as $modulePath) {
            $moduleMigrationsPath = $modulePath . '/migrations';
            if (is_dir($moduleMigrationsPath)) {
                $moduleMigrations = glob($moduleMigrationsPath . '/*.php');
                $migrationFiles = array_merge($migrationFiles, $moduleMigrations);
            }
        }
    }
    
    // Sort all migration files (numeric prefixes ensure correct order)
    sort($migrationFiles);
    
    if (empty($migrationFiles)) {
        echo "No migrations found.\n";
        exit(0);
    }
    
    // Get already run migrations
    $runMigrations = Capsule::table('migrations')->pluck('migration')->toArray();
    
    // If migrate:fresh, drop all tables and clear migrations
    if ($command === 'migrate:fresh') {
        echo "Dropping all tables...\n";
        $tables = Capsule::select('SHOW TABLES');
        $dbName = Capsule::connection()->getDatabaseName();
        $tableKey = "Tables_in_{$dbName}";
        
        foreach ($tables as $table) {
            $tableName = $table->$tableKey;
            if ($tableName !== 'migrations') {
                Capsule::schema()->dropIfExists($tableName);
                echo "  Dropped table: {$tableName}\n";
            }
        }
        
        Capsule::table('migrations')->truncate();
        $runMigrations = [];
        echo "All tables dropped.\n\n";
    }
    
    // Get next batch number
    $batch = Capsule::table('migrations')->max('batch') ?? 0;
    $batch++;
    
    $runCount = 0;
    
    foreach ($migrationFiles as $file) {
        $migrationName = basename($file, '.php');
        
        // Skip if already run
        if (in_array($migrationName, $runMigrations)) {
            continue;
        }
        
        echo "Running migration: {$migrationName}...\n";
        
        try {
            // Check if migration uses create or drop
            $content = file_get_contents($file);
            
            // Execute the migration file
            require $file;
            
            // Record migration
            Capsule::table('migrations')->insert([
                'migration' => $migrationName,
                'batch' => $batch,
            ]);
            
            echo "  ✓ {$migrationName}\n";
            $runCount++;
        } catch (\Exception $e) {
            echo "  ✗ Error: {$e->getMessage()}\n";
            exit(1);
        }
    }
    
    if ($runCount === 0) {
        echo "No new migrations to run.\n";
    } else {
        echo "\n✓ Ran {$runCount} migration(s)\n";
    }
} elseif ($command === 'db:backup') {
    bootstrapApp();
    
    $dbConfig = Config::get('database');
    if (!$dbConfig) {
        echo "Error: Database configuration not found.\n";
        exit(1);
    }
    
    $default = $dbConfig['default'] ?? 'mysql';
    $connection = $dbConfig['connections'][$default] ?? [];
    
    if (empty($connection)) {
        echo "Error: Database connection configuration not found.\n";
        exit(1);
    }
    
    $driver = $connection['driver'] ?? 'mysql';
    $database = $connection['database'] ?? '';
    
    if (empty($database)) {
        echo "Error: Database name not configured.\n";
        exit(1);
    }
    
    // Parse options
    $outputFile = null;
    $maxBackups = null;
    $tables = null;
    $compression = null;
    $useDocker = false;
    
    for ($i = 2; $i < $argc; $i++) {
        $arg = $argv[$i];
        if (strpos($arg, '--file=') === 0) {
            $outputFile = substr($arg, 7);
        } elseif (strpos($arg, '--max=') === 0) {
            $maxBackups = (int)substr($arg, 6);
        } elseif (strpos($arg, '--tables=') === 0) {
            $tables = substr($arg, 9);
        } elseif (strpos($arg, '--compression=') === 0) {
            $compression = strtolower(substr($arg, 15));
            if (!in_array($compression, ['zip', 'tar'])) {
                echo "Error: Compression must be 'zip' or 'tar'.\n";
                exit(1);
            }
        } elseif ($arg === '--docker') {
            $useDocker = true;
        }
    }
    
    // Create backups directory if it doesn't exist
    $backupsDir = __DIR__ . '/database/backups';
    if (!is_dir($backupsDir)) {
        mkdir($backupsDir, 0755, true);
    }
    
    // Generate backup filename
    $timestamp = date('Y-m-d_His');
    $baseFileName = $database . '_' . $timestamp;
    
    if ($outputFile === null) {
        $outputFile = $backupsDir . '/' . $baseFileName . '.sql';
    } else {
        // If path is relative, make it relative to backups directory
        if (strpos($outputFile, '/') !== 0 && strpos($outputFile, '\\') !== 0) {
            $outputFile = $backupsDir . '/' . $outputFile;
        }
        
        // Ensure output directory exists
        $outputDir = dirname($outputFile);
        if (!is_dir($outputDir)) {
            mkdir($outputDir, 0755, true);
        }
    }
    
    // Ensure .sql extension (unless already has an extension)
    if (!preg_match('/\.(sql|gz|bz2|zip|tar)$/i', $outputFile)) {
        $outputFile .= '.sql';
    }
    
    // Determine final output file (before compression)
    $finalOutputFile = $outputFile;
    $sqlFile = $outputFile;
    
    echo "Backing up database: {$database}\n";
    echo "Driver: {$driver}\n";
    if ($tables) {
        echo "Tables: {$tables}\n";
    }
    if ($useDocker) {
        echo "Using Docker: Yes\n";
    }
    
    $success = false;
    $dockerService = 'db'; // Default docker service name for database
    
    // Helper function to wrap command in docker-compose exec if needed
    $wrapDockerCommand = function($command) use ($useDocker, $dockerService) {
        if ($useDocker) {
            // Check if docker-compose is available
            exec('which docker-compose 2>/dev/null', $whichOutput, $whichReturn);
            $dockerComposeCmd = ($whichReturn === 0) ? 'docker-compose' : 'docker compose';
            
            return sprintf(
                '%s exec -T %s sh -c %s',
                $dockerComposeCmd,
                escapeshellarg($dockerService),
                escapeshellarg($command)
            );
        }
        return $command;
    };
    
    if ($driver === 'mysql') {
        $host = $connection['host'] ?? '127.0.0.1';
        $port = $connection['port'] ?? '3306';
        $username = $connection['username'] ?? 'root';
        $password = $connection['password'] ?? '';
        
        // Build mysqldump command
        $dumpCommand = 'mysqldump';
        $dumpArgs = [];
        
        if ($useDocker) {
            // When using docker, connect to localhost (container internal)
            $dumpArgs[] = '-h 127.0.0.1';
        } else {
            $dumpArgs[] = '-h ' . escapeshellarg($host);
            $dumpArgs[] = '-P ' . escapeshellarg($port);
        }
        
        $dumpArgs[] = '-u ' . escapeshellarg($username);
        if ($password) {
            $dumpArgs[] = '-p' . escapeshellarg($password);
        }
        
        // Add table selection if specified
        if ($tables) {
            $tableList = explode(',', $tables);
            $tableList = array_map('trim', $tableList);
            $dumpArgs[] = escapeshellarg($database);
            foreach ($tableList as $table) {
                $dumpArgs[] = escapeshellarg($table);
            }
        } else {
            $dumpArgs[] = escapeshellarg($database);
        }
        
        $command = $dumpCommand . ' ' . implode(' ', $dumpArgs) . ' > ' . escapeshellarg($sqlFile);
        
        // Wrap in docker if needed
        if ($useDocker) {
            // For docker, we need to write to a path inside the container, then copy out
            $containerPath = '/tmp/backup_' . $timestamp . '.sql';
            $dockerCommand = $dumpCommand . ' ' . implode(' ', $dumpArgs) . ' > ' . escapeshellarg($containerPath);
            $command = $wrapDockerCommand($dockerCommand);
            
            // Execute backup
            exec($command . ' 2>&1', $output, $returnVar);
            
            if ($returnVar === 0) {
                // Copy file from container
                exec('which docker-compose 2>/dev/null', $whichOutput, $whichReturn);
                $dockerComposeCmd = ($whichReturn === 0) ? 'docker-compose' : 'docker compose';
                $copyCommand = sprintf(
                    '%s cp %s:%s %s',
                    $dockerComposeCmd,
                    escapeshellarg($dockerService),
                    escapeshellarg($containerPath),
                    escapeshellarg($sqlFile)
                );
                exec($copyCommand . ' 2>&1', $copyOutput, $copyReturn);
                
                if ($copyReturn === 0 && file_exists($sqlFile)) {
                    // Clean up container file
                    $cleanupCommand = $wrapDockerCommand('rm ' . escapeshellarg($containerPath));
                    exec($cleanupCommand);
                    $success = true;
                } else {
                    echo "Error: Failed to copy backup from container.\n";
                    if (!empty($copyOutput)) {
                        echo implode("\n", $copyOutput) . "\n";
                    }
                    exit(1);
                }
            } else {
                echo "Error: Backup failed.\n";
                if (!empty($output)) {
                    echo implode("\n", $output) . "\n";
                }
                exit(1);
            }
        } else {
            // Execute backup
            exec($command . ' 2>&1', $output, $returnVar);
            
            if ($returnVar === 0 && file_exists($sqlFile)) {
                $success = true;
            } else {
                echo "Error: Backup failed.\n";
                if (!empty($output)) {
                    echo implode("\n", $output) . "\n";
                }
                exit(1);
            }
        }
        
    } elseif ($driver === 'pgsql' || $driver === 'postgres') {
        $host = $connection['host'] ?? '127.0.0.1';
        $port = $connection['port'] ?? '5432';
        $username = $connection['username'] ?? 'postgres';
        $password = $connection['password'] ?? '';
        
        // Set PGPASSWORD environment variable for pg_dump
        if ($password && !$useDocker) {
            putenv('PGPASSWORD=' . $password);
        }
        
        // Build pg_dump command
        $dumpCommand = 'pg_dump';
        $dumpArgs = [];
        
        if ($useDocker) {
            $dumpArgs[] = '-h 127.0.0.1';
        } else {
            $dumpArgs[] = '-h ' . escapeshellarg($host);
            $dumpArgs[] = '-p ' . escapeshellarg($port);
        }
        
        $dumpArgs[] = '-U ' . escapeshellarg($username);
        $dumpArgs[] = '-f ' . escapeshellarg($sqlFile);
        
        // Add table selection if specified
        if ($tables) {
            $tableList = explode(',', $tables);
            $tableList = array_map('trim', $tableList);
            foreach ($tableList as $table) {
                $dumpArgs[] = '-t ' . escapeshellarg($table);
            }
        }
        
        $dumpArgs[] = escapeshellarg($database);
        
        $command = $dumpCommand . ' ' . implode(' ', $dumpArgs);
        
        // Wrap in docker if needed
        if ($useDocker) {
            $containerPath = '/tmp/backup_' . $timestamp . '.sql';
            $dockerCommand = str_replace(escapeshellarg($sqlFile), escapeshellarg($containerPath), $command);
            if ($password) {
                $dockerCommand = 'PGPASSWORD=' . escapeshellarg($password) . ' ' . $dockerCommand;
            }
            $command = $wrapDockerCommand($dockerCommand);
            
            exec($command . ' 2>&1', $output, $returnVar);
            
            if ($returnVar === 0) {
                exec('which docker-compose 2>/dev/null', $whichOutput, $whichReturn);
                $dockerComposeCmd = ($whichReturn === 0) ? 'docker-compose' : 'docker compose';
                $copyCommand = sprintf(
                    '%s cp %s:%s %s',
                    $dockerComposeCmd,
                    escapeshellarg($dockerService),
                    escapeshellarg($containerPath),
                    escapeshellarg($sqlFile)
                );
                exec($copyCommand . ' 2>&1', $copyOutput, $copyReturn);
                
                if ($copyReturn === 0 && file_exists($sqlFile)) {
                    $cleanupCommand = $wrapDockerCommand('rm ' . escapeshellarg($containerPath));
                    exec($cleanupCommand);
                    $success = true;
                } else {
                    echo "Error: Failed to copy backup from container.\n";
                    if (!empty($copyOutput)) {
                        echo implode("\n", $copyOutput) . "\n";
                    }
                    exit(1);
                }
            } else {
                echo "Error: Backup failed.\n";
                if (!empty($output)) {
                    echo implode("\n", $output) . "\n";
                }
                exit(1);
            }
        } else {
            exec($command . ' 2>&1', $output, $returnVar);
            
            if ($returnVar === 0 && file_exists($sqlFile)) {
                $success = true;
            } else {
                echo "Error: Backup failed.\n";
                if (!empty($output)) {
                    echo implode("\n", $output) . "\n";
                }
                exit(1);
            }
        }
        
    } elseif ($driver === 'sqlite') {
        $databasePath = $connection['database'];
        
        // SQLite database is a file, so we'll create a SQL dump
        if ($useDocker) {
            // For docker, we need to access the file inside the container
            $containerDbPath = $databasePath;
            $command = 'sqlite3 ' . escapeshellarg($containerDbPath) . ' .dump > ' . escapeshellarg('/tmp/backup_' . $timestamp . '.sql');
            $command = $wrapDockerCommand($command);
            
            exec($command . ' 2>&1', $output, $returnVar);
            
            if ($returnVar === 0) {
                exec('which docker-compose 2>/dev/null', $whichOutput, $whichReturn);
                $dockerComposeCmd = ($whichReturn === 0) ? 'docker-compose' : 'docker compose';
                $copyCommand = sprintf(
                    '%s cp %s:/tmp/backup_%s.sql %s',
                    $dockerComposeCmd,
                    escapeshellarg($dockerService),
                    $timestamp,
                    escapeshellarg($sqlFile)
                );
                exec($copyCommand . ' 2>&1', $copyOutput, $copyReturn);
                
                if ($copyReturn === 0 && file_exists($sqlFile)) {
                    $success = true;
                } else {
                    echo "Error: Failed to copy backup from container.\n";
                    if (!empty($copyOutput)) {
                        echo implode("\n", $copyOutput) . "\n";
                    }
                    exit(1);
                }
            } else {
                echo "Error: Backup failed.\n";
                if (!empty($output)) {
                    echo implode("\n", $output) . "\n";
                }
                exit(1);
            }
        } else {
            if (!file_exists($databasePath)) {
                echo "Error: SQLite database file not found: {$databasePath}\n";
                exit(1);
            }
            
            // Use sqlite3 to dump the database
            $command = sprintf(
                'sqlite3 %s .dump > %s',
                escapeshellarg($databasePath),
                escapeshellarg($sqlFile)
            );
            
            exec($command . ' 2>&1', $output, $returnVar);
            
            if ($returnVar === 0 && file_exists($sqlFile)) {
                $success = true;
            } else {
                echo "Error: Backup failed.\n";
                if (!empty($output)) {
                    echo implode("\n", $output) . "\n";
                }
                exit(1);
            }
        }
        
    } else {
        echo "Error: Unsupported database driver: {$driver}\n";
        echo "Supported drivers: mysql, pgsql, postgres, sqlite\n";
        exit(1);
    }
    
    if ($success) {
        // Apply compression if requested
        if ($compression === 'zip') {
            // Replace extension with .zip, or append .zip if no extension
            if (preg_match('/\.(sql|gz|bz2|tar)$/i', $sqlFile)) {
                $zipFile = preg_replace('/\.(sql|gz|bz2|tar)$/i', '.zip', $sqlFile);
            } else {
                $zipFile = $sqlFile . '.zip';
            }
            
            $zip = new \ZipArchive();
            if ($zip->open($zipFile, \ZipArchive::CREATE | \ZipArchive::OVERWRITE) === true) {
                $zip->addFile($sqlFile, basename($sqlFile));
                $zip->close();
                unlink($sqlFile);
                $finalOutputFile = $zipFile;
                echo "✓ Compressed backup to ZIP\n";
            } else {
                echo "Warning: Failed to create ZIP file, keeping SQL backup.\n";
                $finalOutputFile = $sqlFile;
            }
        } elseif ($compression === 'tar') {
            // Replace extension with .tar.gz, or append .tar.gz if no extension
            if (preg_match('/\.(sql|gz|bz2|zip)$/i', $sqlFile)) {
                $tarFile = preg_replace('/\.(sql|gz|bz2|zip)$/i', '.tar.gz', $sqlFile);
            } else {
                $tarFile = $sqlFile . '.tar.gz';
            }
            
            $command = sprintf(
                'tar -czf %s -C %s %s',
                escapeshellarg($tarFile),
                escapeshellarg(dirname($sqlFile)),
                escapeshellarg(basename($sqlFile))
            );
            exec($command . ' 2>&1', $tarOutput, $tarReturn);
            if ($tarReturn === 0 && file_exists($tarFile)) {
                unlink($sqlFile);
                $finalOutputFile = $tarFile;
                echo "✓ Compressed backup to TAR.GZ\n";
            } else {
                echo "Warning: Failed to create TAR file, keeping SQL backup.\n";
                if (!empty($tarOutput)) {
                    echo implode("\n", $tarOutput) . "\n";
                }
                $finalOutputFile = $sqlFile;
            }
        } else {
            $finalOutputFile = $sqlFile;
        }
        
        // Clean up old backups if --max is specified
        if ($maxBackups !== null && $maxBackups > 0) {
            // Get all backup files matching the database pattern
            $extensions = ['sql', 'sql.gz', 'sql.bz2', 'zip', 'tar', 'tar.gz'];
            $backupFiles = [];
            
            foreach ($extensions as $ext) {
                $pattern = $backupsDir . '/' . $database . '_*.' . $ext;
                $files = glob($pattern);
                $backupFiles = array_merge($backupFiles, $files);
            }
            
            // Sort by modification time (newest first)
            usort($backupFiles, function($a, $b) {
                return filemtime($b) - filemtime($a);
            });
            
            // Keep only the specified number of backups
            if (count($backupFiles) > $maxBackups) {
                $filesToDelete = array_slice($backupFiles, $maxBackups);
                foreach ($filesToDelete as $file) {
                    if (file_exists($file)) {
                        unlink($file);
                        echo "  Deleted old backup: " . basename($file) . "\n";
                    }
                }
                echo "  Kept {$maxBackups} most recent backup(s)\n";
            }
        }
        
        $fileSize = filesize($finalOutputFile);
        $fileSizeFormatted = $fileSize < 1024 
            ? $fileSize . ' B' 
            : ($fileSize < 1048576 
                ? round($fileSize / 1024, 2) . ' KB' 
                : round($fileSize / 1048576, 2) . ' MB');
        
        echo "✓ Backup created successfully: {$finalOutputFile}\n";
        echo "  Size: {$fileSizeFormatted}\n";
    }
} elseif ($command === 'db:seed') {
    // Bootstrap full application for facades and other services
    require_once __DIR__ . '/vendor/autoload.php';
    require_once __DIR__ . '/src/Core/helpers.php';
    $app = new \IsekaiPHP\Core\Application(__DIR__);
    
    // Set up Laravel facades with Illuminate container for compatibility
    if (class_exists('Illuminate\Support\Facades\Facade')) {
        $illuminateContainer = new \Illuminate\Container\Container();
        
        // Register hash service for Hash facade
        $illuminateContainer->singleton('hash', function() {
            return new class {
                public function make($value, array $options = []) {
                    return password_hash($value, PASSWORD_BCRYPT, $options);
                }
                public function check($value, $hashedValue, array $options = []) {
                    return password_verify($value, $hashedValue);
                }
            };
        });
        
        \Illuminate\Support\Facades\Facade::setFacadeApplication($illuminateContainer);
    }
    
    $seedsPath = __DIR__ . '/database/seeds';
    
    if (!is_dir($seedsPath)) {
        echo "Error: Seeds directory not found at {$seedsPath}\n";
        exit(1);
    }
    
    // Get specific seed class if provided
    $specificSeed = $argv[2] ?? null;
    
    if ($specificSeed) {
        // Run specific seed class
        $seedName = $specificSeed;
        // Remove .php extension if present
        if (str_ends_with($seedName, '.php')) {
            $seedName = substr($seedName, 0, -4);
        }
        // Convert to class name format
        $toClassName = function($name) {
            return str_replace(' ', '', ucwords(str_replace(['-', '_'], ' ', $name)));
        };
        $className = $toClassName($seedName);
        
        $seedFile = $seedsPath . '/' . $className . '.php';
        
        if (!file_exists($seedFile)) {
            // Try with original name
            $seedFile = $seedsPath . '/' . $seedName . '.php';
            if (!file_exists($seedFile)) {
                echo "Error: Seed class {$className} not found.\n";
                exit(1);
            }
            $className = $seedName;
        }
        
        echo "Running seed: {$className}...\n";
        
        try {
            require_once $seedFile;
            $fullClassName = 'Database\\Seeds\\' . $className;
            
            if (!class_exists($fullClassName)) {
                echo "Error: Class {$fullClassName} not found in {$seedFile}\n";
                exit(1);
            }
            
            $seed = new $fullClassName();
            $seed->run();
            
            echo "  ✓ {$className}\n";
        } catch (\Exception $e) {
            echo "  ✗ Error: {$e->getMessage()}\n";
            exit(1);
        }
    } else {
        // Run all seeds
        $seedFiles = glob($seedsPath . '/*.php');
        
        if (empty($seedFiles)) {
            echo "No seeds found.\n";
            exit(0);
        }
        
        // Sort seed files alphabetically
        sort($seedFiles);
        
        echo "Running database seeds...\n\n";
        
        $runCount = 0;
        
        foreach ($seedFiles as $seedFile) {
            $className = basename($seedFile, '.php');
            
            echo "Running seed: {$className}...\n";
            
            try {
                require_once $seedFile;
                $fullClassName = 'Database\\Seeds\\' . $className;
                
                if (!class_exists($fullClassName)) {
                    echo "  ⚠ Warning: Class {$fullClassName} not found, skipping.\n\n";
                    continue;
                }
                
                $seed = new $fullClassName();
                $seed->run();
                
                echo "  ✓ {$className}\n\n";
                $runCount++;
            } catch (\Exception $e) {
                echo "  ✗ Error: {$e->getMessage()}\n\n";
                exit(1);
            }
        }
        
        if ($runCount === 0) {
            echo "No seeds were run.\n";
        } else {
            echo "✓ Ran {$runCount} seed(s)\n";
        }
    }
} elseif ($command === 'serve') {
    $host = '127.0.0.1';
    $port = 8000;
    
    // Parse options
    for ($i = 2; $i < $argc; $i++) {
        if (strpos($argv[$i], '--host=') === 0) {
            $host = substr($argv[$i], 7);
        } elseif (strpos($argv[$i], '--port=') === 0) {
            $port = (int)substr($argv[$i], 7);
        }
    }
    
    $publicPath = __DIR__ . '/public';
    $routerPath = $publicPath . '/router.php';
    
    // Create router.php if it doesn't exist
    if (!file_exists($routerPath)) {
        $routerContent = <<<'PHP'
<?php
/**
 * Router script for PHP built-in server
 * 
 * This script handles static file serving and routes non-existent files
 * through the application.
 */

$uri = urldecode(parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));

// Get the requested file path
$requestedFile = __DIR__ . $uri;

// If the requested file exists and is a static file, serve it directly
if ($uri !== '/' && file_exists($requestedFile) && is_file($requestedFile)) {
    // Check if it's a static file (not PHP)
    $extension = strtolower(pathinfo($requestedFile, PATHINFO_EXTENSION));
    $staticExtensions = ['js', 'css', 'png', 'jpg', 'jpeg', 'gif', 'svg', 'ico', 'woff', 'woff2', 'ttf', 'eot', 'json', 'xml', 'txt', 'pdf', 'zip'];
    
    if (in_array($extension, $staticExtensions)) {
        // Let PHP built-in server handle it
        return false;
    }
}

// Route through the application
require_once __DIR__ . '/index.php';
PHP;
        file_put_contents($routerPath, $routerContent);
    }
    
    if (!file_exists($publicPath . '/index.php')) {
        echo "Error: Public index.php not found at {$publicPath}/index.php\n";
        exit(1);
    }
    
    echo "IsekaiPHP development server started: http://{$host}:{$port}\n";
    echo "Press Ctrl+C to stop the server\n\n";
    
    // Start PHP built-in server
    $command = sprintf(
        'php -S %s:%d -t %s %s',
        escapeshellarg($host),
        $port,
        escapeshellarg($publicPath),
        escapeshellarg($routerPath)
    );
    
    passthru($command);
} elseif (strpos($command, 'module:') === 0) {
    // Module command handler
    bootstrapApp();
    
    $parts = explode(':', $command);
    $moduleCommand = $parts[1] ?? null;
    
    if ($moduleCommand === 'make') {
        if (!isset($argv[2])) {
            echo "Error: Module name is required\n";
            echo "Usage: php isekai module:make <name>\n";
            exit(1);
        }
        
        $moduleName = $argv[2];
        $modulesPath = __DIR__ . '/modules';
        $modulePath = $modulesPath . '/' . $moduleName;
        
        if (is_dir($modulePath)) {
            echo "Error: Module {$moduleName} already exists.\n";
            exit(1);
        }
        
        // Create module directory structure
        mkdir($modulePath, 0755, true);
        mkdir($modulePath . '/routes', 0755, true);
        mkdir($modulePath . '/views', 0755, true);
        mkdir($modulePath . '/migrations', 0755, true);
        mkdir($modulePath . '/config', 0755, true);
        mkdir($modulePath . '/assets/css', 0755, true);
        mkdir($modulePath . '/assets/js', 0755, true);
        mkdir($modulePath . '/src', 0755, true);
        
        // Convert module name to class name
        $toClassName = function($name) {
            return str_replace(' ', '', ucwords(str_replace(['-', '_'], ' ', $name)));
        };
        
        $className = $toClassName($moduleName);
        $namespace = $className;
        
        // Create module.json
        $moduleJson = [
            'name' => $moduleName,
            'display_name' => $className . ' Module',
            'version' => '1.0.0',
            'description' => "A module for IsekaiPHP",
            'author' => '',
            'license' => 'MIT',
            'requires' => [
                'modules' => []
            ],
            'extensions' => [
                'mail_drivers' => [],
                'cache_drivers' => [],
                'storage_drivers' => []
            ],
            'extra' => [
                'module' => [
                    'namespace' => $namespace,
                    'class' => $namespace . '\\Module',
                    'service_provider' => $namespace . '\\ServiceProvider'
                ]
            ]
        ];
        
        file_put_contents($modulePath . '/module.json', json_encode($moduleJson, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
        
        // Create composer.json
        $composerJson = [
            'name' => strtolower($moduleName) . '/' . strtolower($moduleName),
            'description' => "A module for IsekaiPHP",
            'type' => 'isekaiphp-module',
            'require' => [
                'php' => '^8.4',
                'isekaiphp/framework' => 'dev-main'
            ],
            'repositories' => [
                [
                    'type' => 'vcs',
                    'url' => 'https://github.com/Ryahn/IsekaiPHP'
                ]
            ],
            'minimum-stability' => 'dev',
            'prefer-stable' => true,
            'autoload' => [
                'psr-4' => [
                    $namespace . '\\' => 'src/'
                ]
            ]
        ];
        
        file_put_contents($modulePath . '/composer.json', json_encode($composerJson, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
        
        // Create Module.php in src directory
        $moduleStub = "<?php\n\nnamespace {$namespace};\n\nuse IsekaiPHP\\Core\\Module as BaseModule;\nuse IsekaiPHP\\Core\\Container;\n\nclass Module extends BaseModule\n{\n    /**\n     * Register the module\n     */\n    public function register(Container \$container): void\n    {\n        // Register services here\n    }\n\n    /**\n     * Boot the module\n     */\n    public function boot(Container \$container): void\n    {\n        // Boot services here\n    }\n}\n";
        file_put_contents($modulePath . '/src/Module.php', $moduleStub);
        
        // Create ServiceProvider.php in src directory
        $serviceProviderStub = "<?php\n\nnamespace {$namespace};\n\nuse IsekaiPHP\\Core\\ServiceProvider as BaseServiceProvider;\nuse IsekaiPHP\\Core\\Container;\n\nclass ServiceProvider implements BaseServiceProvider\n{\n    /**\n     * Register services\n     */\n    public function register(Container \$container): void\n    {\n        // Bind services here\n    }\n\n    /**\n     * Boot services\n     */\n    public function boot(Container \$container): void\n    {\n        // Boot services here\n    }\n}\n";
        file_put_contents($modulePath . '/src/ServiceProvider.php', $serviceProviderStub);
        
        // Create route files
        $webRoutesStub = "<?php\n\n/** @var \\IsekaiPHP\\Http\\Router \$router */\n\$router = \$GLOBALS['app']->getRouter();\n\n// Add your routes here\n";
        file_put_contents($modulePath . '/routes/web.php', $webRoutesStub);
        
        $apiRoutesStub = "<?php\n\n/** @var \\IsekaiPHP\\Http\\Router \$router */\n\$router = \$GLOBALS['app']->getRouter();\n\n// Add your API routes here\n";
        file_put_contents($modulePath . '/routes/api.php', $apiRoutesStub);
        
        // Create README.md
        // Create sample config file
        $configStub = "<?php\n\nreturn [\n    // Module configuration\n    'enabled' => true,\n];\n";
        file_put_contents($modulePath . '/config/module.php', $configStub);
        
        // Create README.md
        $readmeStub = "# {$className} Module\n\nA module for IsekaiPHP.\n\n## Installation\n\nRun `composer install` in this directory to install dependencies.\n\n## Configuration\n\nEdit `config/module.php` to configure the module.\n\n## Usage\n\nAdd your module functionality here.\n\n## Module Structure\n\n- `Module.php` - Main module class\n- `ServiceProvider.php` - Service provider for dependency injection\n- `routes/` - Route definitions\n- `views/` - Blade templates\n- `migrations/` - Database migrations\n- `config/` - Configuration files\n- `assets/` - CSS, JS, and other assets\n";
        file_put_contents($modulePath . '/README.md', $readmeStub);
        
        echo "✓ Module created: {$modulePath}\n";
        echo "  Run 'composer install' in the module directory to install dependencies.\n";
        echo "  Use 'php isekai module:publish {$moduleName}' to publish assets.\n";
        
    } elseif ($moduleCommand === 'list') {
        $modulesPath = __DIR__ . '/modules';
        
        if (!is_dir($modulesPath)) {
            echo "No modules directory found.\n";
            exit(0);
        }
        
        $directories = array_filter(glob($modulesPath . '/*'), 'is_dir');
        
        if (empty($directories)) {
            echo "No modules found.\n";
            exit(0);
        }
        
        echo "Installed Modules:\n\n";
        
        foreach ($directories as $modulePath) {
            $moduleJsonPath = $modulePath . '/module.json';
            $moduleName = basename($modulePath);
            
            if (file_exists($moduleJsonPath)) {
                $manifest = json_decode(file_get_contents($moduleJsonPath), true);
                $displayName = $manifest['display_name'] ?? $moduleName;
                $version = $manifest['version'] ?? 'N/A';
                $description = $manifest['description'] ?? '';
                $dependencies = $manifest['requires']['modules'] ?? [];
                
                $config = Config::get('modules', []);
                $disabled = $config['disabled'] ?? [];
                $status = in_array($moduleName, $disabled) ? 'Disabled' : 'Enabled';
                
                echo "  {$displayName} ({$moduleName})\n";
                echo "    Version: {$version}\n";
                echo "    Status: {$status}\n";
                if ($description) {
                    echo "    Description: {$description}\n";
                }
                if (!empty($dependencies)) {
                    $depList = implode(', ', array_keys($dependencies));
                    echo "    Dependencies: {$depList}\n";
                }
                echo "\n";
            } else {
                echo "  {$moduleName} (no module.json)\n\n";
            }
        }
        
    } elseif ($moduleCommand === 'enable') {
        if (!isset($argv[2])) {
            echo "Error: Module name is required\n";
            echo "Usage: php isekai module:enable <name>\n";
            exit(1);
        }
        
        $moduleName = $argv[2];
        $configPath = __DIR__ . '/config/modules.php';
        $config = require $configPath;
        
        $disabled = $config['disabled'] ?? [];
        $key = array_search($moduleName, $disabled);
        
        if ($key !== false) {
            unset($disabled[$key]);
            $config['disabled'] = array_values($disabled);
            
            $configContent = "<?php\n\nreturn " . var_export($config, true) . ";\n";
            file_put_contents($configPath, $configContent);
            
            echo "✓ Module {$moduleName} enabled.\n";
        } else {
            echo "Module {$moduleName} is already enabled.\n";
        }
        
    } elseif ($moduleCommand === 'disable') {
        if (!isset($argv[2])) {
            echo "Error: Module name is required\n";
            echo "Usage: php isekai module:disable <name>\n";
            exit(1);
        }
        
        $moduleName = $argv[2];
        $configPath = __DIR__ . '/config/modules.php';
        $config = require $configPath;
        
        $disabled = $config['disabled'] ?? [];
        
        if (!in_array($moduleName, $disabled)) {
            $disabled[] = $moduleName;
            $config['disabled'] = $disabled;
            
            $configContent = "<?php\n\nreturn " . var_export($config, true) . ";\n";
            file_put_contents($configPath, $configContent);
            
            echo "✓ Module {$moduleName} disabled.\n";
        } else {
            echo "Module {$moduleName} is already disabled.\n";
        }
        
    } elseif ($moduleCommand === 'install') {
        if (!isset($argv[2])) {
            echo "Error: Module name is required\n";
            echo "Usage: php isekai module:install <name>\n";
            exit(1);
        }
        
        $moduleName = $argv[2];
        $modulePath = __DIR__ . '/modules/' . $moduleName;
        
        if (!is_dir($modulePath)) {
            echo "Error: Module {$moduleName} not found.\n";
            exit(1);
        }
        
        $composerJsonPath = $modulePath . '/composer.json';
        
        if (!file_exists($composerJsonPath)) {
            echo "Module {$moduleName} does not have a composer.json file.\n";
            exit(0);
        }
        
        echo "Installing dependencies for module {$moduleName}...\n";
        
        $command = sprintf(
            'cd %s && composer install --no-interaction',
            escapeshellarg($modulePath)
        );
        
        passthru($command);
        
    } elseif ($moduleCommand === 'install-all') {
        $modulesPath = __DIR__ . '/modules';
        
        if (!is_dir($modulesPath)) {
            echo "No modules directory found.\n";
            exit(0);
        }
        
        $directories = array_filter(glob($modulesPath . '/*'), 'is_dir');
        
        if (empty($directories)) {
            echo "No modules found.\n";
            exit(0);
        }
        
        foreach ($directories as $modulePath) {
            $moduleName = basename($modulePath);
            $composerJsonPath = $modulePath . '/composer.json';
            
            if (!file_exists($composerJsonPath)) {
                continue;
            }
            
            echo "Installing dependencies for module {$moduleName}...\n";
            
            $command = sprintf(
                'cd %s && composer install --no-interaction',
                escapeshellarg($modulePath)
            );
            
            passthru($command);
            echo "\n";
        }
        
        echo "✓ All module dependencies installed.\n";
        
    } elseif ($moduleCommand === 'publish') {
        if (!isset($argv[2])) {
            echo "Error: Module name is required\n";
            echo "Usage: php isekai module:publish <name> [--force]\n";
            exit(1);
        }
        
        $moduleName = $argv[2];
        $force = isset($argv[3]) && $argv[3] === '--force';
        
        // Create application instance to get module manager
        require_once __DIR__ . '/vendor/autoload.php';
        require_once __DIR__ . '/src/Core/helpers.php';
        $app = new \IsekaiPHP\Core\Application(__DIR__);
        $moduleManager = $app->getModuleManager();
        
        if (!$moduleManager) {
            echo "Error: Module manager not initialized.\n";
            exit(1);
        }
        
        if ($moduleManager->publishAssets($moduleName, $force)) {
            echo "✓ Assets published for module {$moduleName}.\n";
        } else {
            if ($force) {
                echo "Error: Failed to publish assets for module {$moduleName}.\n";
                exit(1);
            } else {
                echo "Module {$moduleName} assets already published. Use --force to overwrite.\n";
            }
        }
        
    } elseif ($moduleCommand === 'publish-all') {
        $force = isset($argv[2]) && $argv[2] === '--force';
        
        // Create application instance to get module manager
        require_once __DIR__ . '/vendor/autoload.php';
        require_once __DIR__ . '/src/Core/helpers.php';
        $app = new \IsekaiPHP\Core\Application(__DIR__);
        $moduleManager = $app->getModuleManager();
        
        if (!$moduleManager) {
            echo "Error: Module manager not initialized.\n";
            exit(1);
        }
        
        $modules = $moduleManager->getModules();
        $published = 0;
        
        foreach ($modules as $moduleName => $module) {
            if ($moduleManager->publishAssets($moduleName, $force)) {
                echo "✓ Published assets for module {$moduleName}\n";
                $published++;
            }
        }
        
        if ($published > 0) {
            echo "\n✓ Published assets for {$published} module(s).\n";
        } else {
            echo "No assets to publish or all assets already published.\n";
        }
        
    } else {
        echo "Error: Unknown module command: module:{$moduleCommand}\n";
        echo "Available commands: module:make, module:list, module:enable, module:disable, module:install, module:install-all, module:publish, module:publish-all\n";
        exit(1);
    }
} elseif ($command === 'cache:clear') {
    bootstrapApp();
    
    $cacheConfig = Config::get('cache', []);
    $cacheManager = new \IsekaiPHP\Cache\CacheManager($cacheConfig);
    
    if ($cacheManager->flush()) {
        echo "✓ Cache cleared successfully.\n";
    } else {
        echo "Error: Failed to clear cache.\n";
        exit(1);
    }
} elseif ($command === 'route:list') {
    bootstrapApp();
    
    require_once __DIR__ . '/vendor/autoload.php';
    require_once __DIR__ . '/src/Core/helpers.php';
    $app = new \IsekaiPHP\Core\Application(__DIR__);
    $router = $app->getRouter();
    
    // Get routes using reflection or add a method to Router
    echo "Registered Routes:\n\n";
    echo "Note: Route listing requires Router enhancement.\n";
    echo "Routes are registered but listing functionality needs to be added.\n";
} elseif (strpos($command, 'make:') === 0) {
    // Make command handler
    $parts = explode(':', $command);
    $makeType = $parts[1] ?? null;
    
    if (!isset($argv[2])) {
        echo "Error: Name is required for make:{$makeType}\n";
        echo "Usage: php isekai make:{$makeType} <name> [options]\n";
        exit(1);
    }
    
    $name = $argv[2];
    
    // Parse flags and options from remaining arguments
    $flags = [];
    $options = [];
    
    for ($i = 3; $i < $argc; $i++) {
        $arg = $argv[$i];
        
        // Parse long options (--option=value)
        if (strpos($arg, '--') === 0) {
            if (strpos($arg, '=') !== false) {
                list($opt, $val) = explode('=', substr($arg, 2), 2);
                $options[$opt] = $val;
            } else {
                $options[substr($arg, 2)] = true;
            }
        }
        // Parse short flags (-abc or -a -b -c)
        elseif (strpos($arg, '-') === 0) {
            $flagString = substr($arg, 1);
            for ($j = 0; $j < strlen($flagString); $j++) {
                $flags[$flagString[$j]] = true;
            }
        }
    }
    
    // Helper function to convert name to class name
    $toClassName = function($name) {
        return str_replace(' ', '', ucwords(str_replace(['-', '_'], ' ', $name)));
    };
    
    // Helper function to convert name to table name
    $toTableName = function($name) {
        return str_replace('_', '-', strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $name)));
    };
    
    // Helper function to get namespace from path
    $getNamespace = function($path, $basePath) {
        $relativePath = str_replace($basePath . '/', '', $path);
        $relativePath = str_replace('/', '\\', dirname($relativePath));
        $relativePath = str_replace('src\\', 'IsekaiPHP\\', $relativePath);
        return $relativePath === '.' ? 'IsekaiPHP' : $relativePath;
    };
    
    // Helper function to create a controller
    $createController = function($controllerName, $baseName = null) use ($toClassName, $getNamespace) {
        $className = $toClassName($controllerName);
        $controllerPath = __DIR__ . '/src/Http/Controllers';
        
        // Handle nested controllers (e.g., Admin/UserController)
        if (strpos($controllerName, '/') !== false) {
            $parts = explode('/', $controllerName);
            $className = $toClassName(array_pop($parts));
            $subDir = implode('/', $parts);
            $controllerPath .= '/' . $subDir;
            if (!is_dir($controllerPath)) {
                mkdir($controllerPath, 0755, true);
            }
            $namespace = 'IsekaiPHP\\Http\\Controllers\\' . str_replace('/', '\\', $subDir);
        } else {
            $namespace = 'IsekaiPHP\\Http\\Controllers';
        }
        
        $filePath = $controllerPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Controller {$className} already exists.\n";
            return false;
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/controller.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        $stub = str_replace('namespace IsekaiPHP\\Http\\Controllers;', "namespace {$namespace};", $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Controller created: {$filePath}\n";
        return true;
    };
    
    // Helper function to create a model
    $createModel = function($modelName) use ($toClassName, $toTableName) {
        $className = $toClassName($modelName);
        $modelPath = __DIR__ . '/src/Models';
        $filePath = $modelPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Model {$className} already exists.\n";
            return false;
        }
        
        $tableName = $toTableName($className);
        // Pluralize table name (simple version)
        if (!str_ends_with($tableName, 's')) {
            $tableName .= 's';
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/model.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        $stub = str_replace('{{TABLE_NAME}}', $tableName, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Model created: {$filePath}\n";
        return true;
    };
    
    // Helper function to create a migration
    $createMigration = function($migrationName, $tableName = null) use ($toTableName, $toClassName) {
        $timestamp = date('Y_m_d_His');
        $migrationPath = __DIR__ . '/database/migrations';
        
        // Convert name to snake_case
        $snakeName = strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $migrationName));
        $snakeName = str_replace(['-', ' '], '_', $snakeName);
        
        // If table name is provided, use it as-is (it's already been calculated correctly)
        // Otherwise try to extract from migration name
        if ($tableName === null) {
            $tableName = $snakeName;
            if (preg_match('/create_(.+)_table/', $snakeName, $matches)) {
                $tableName = $matches[1];
            } elseif (preg_match('/add_(.+)_to_(.+)_table/', $snakeName, $matches)) {
                $tableName = $matches[2];
            } elseif (preg_match('/drop_(.+)_from_(.+)_table/', $snakeName, $matches)) {
                $tableName = $matches[2];
            }
        }
        // $tableName is already in the correct format if provided
        
        $fileName = $timestamp . '_' . $snakeName . '.php';
        $filePath = $migrationPath . '/' . $fileName;
        
        if (file_exists($filePath)) {
            echo "Error: Migration {$fileName} already exists.\n";
            return false;
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/migration.stub');
        $stub = str_replace('{{TABLE_NAME}}', $tableName, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Migration created: {$filePath}\n";
        return true;
    };
    
    if ($makeType === 'controller') {
        $className = $toClassName($name);
        $controllerPath = __DIR__ . '/src/Http/Controllers';
        
        // Handle nested controllers (e.g., Admin/UserController)
        if (strpos($name, '/') !== false) {
            $parts = explode('/', $name);
            $className = $toClassName(array_pop($parts));
            $subDir = implode('/', $parts);
            $controllerPath .= '/' . $subDir;
            if (!is_dir($controllerPath)) {
                mkdir($controllerPath, 0755, true);
            }
            $namespace = 'IsekaiPHP\\Http\\Controllers\\' . str_replace('/', '\\', $subDir);
        } else {
            $namespace = 'IsekaiPHP\\Http\\Controllers';
        }
        
        $filePath = $controllerPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Controller {$className} already exists.\n";
            exit(1);
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/controller.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        $stub = str_replace('namespace IsekaiPHP\\Http\\Controllers;', "namespace {$namespace};", $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Controller created: {$filePath}\n";
        
        // Handle flags: -m (model), -d (migration)
        // Handle options: --model=NAME
        if (isset($flags['m']) || isset($options['model'])) {
            $modelName = $options['model'] ?? $name;
            // Remove "Controller" suffix if present for model name
            if (str_ends_with($modelName, 'Controller')) {
                $modelName = substr($modelName, 0, -10);
            }
            $createModel($modelName);
        }
        
        if (isset($flags['d']) || isset($options['migration'])) {
            $migrationName = $options['migration'] ?? 'create_' . strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $name)) . '_table';
            // Remove "Controller" suffix if present
            if (str_ends_with($migrationName, '_controller')) {
                $migrationName = substr($migrationName, 0, -11);
            }
            // Extract table name from model name if model was created, otherwise from controller name
            $tableName = null;
            if (isset($flags['m']) || isset($options['model'])) {
                $modelNameForTable = $options['model'] ?? $name;
                if (str_ends_with($modelNameForTable, 'Controller')) {
                    $modelNameForTable = substr($modelNameForTable, 0, -10);
                }
                $tableName = $toTableName($toClassName($modelNameForTable));
                if (!str_ends_with($tableName, 's')) {
                    $tableName .= 's';
                }
            } else {
                // Extract from controller name
                $controllerNameForTable = $name;
                if (str_ends_with($controllerNameForTable, 'Controller')) {
                    $controllerNameForTable = substr($controllerNameForTable, 0, -10);
                }
                $tableName = $toTableName($toClassName($controllerNameForTable));
                if (!str_ends_with($tableName, 's')) {
                    $tableName .= 's';
                }
            }
            $createMigration($migrationName, $tableName);
        }
        
    } elseif ($makeType === 'model') {
        $className = $toClassName($name);
        $modelPath = __DIR__ . '/src/Models';
        $filePath = $modelPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Model {$className} already exists.\n";
            exit(1);
        }
        
        $tableName = $toTableName($className);
        // Pluralize table name (simple version)
        if (!str_ends_with($tableName, 's')) {
            $tableName .= 's';
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/model.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        $stub = str_replace('{{TABLE_NAME}}', $tableName, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Model created: {$filePath}\n";
        
        // Handle flags: -c (controller), -m (migration)
        // Handle options: --controller=NAME
        if (isset($flags['c']) || isset($options['controller'])) {
            $controllerName = $options['controller'] ?? $name . 'Controller';
            $createController($controllerName, $name);
        }
        
        if (isset($flags['m']) || isset($options['migration'])) {
            $migrationName = $options['migration'] ?? 'create_' . strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $name)) . '_table';
            $createMigration($migrationName, $tableName);
        }
        
    } elseif ($makeType === 'middleware') {
        $className = $toClassName($name);
        $middlewarePath = __DIR__ . '/src/Http/Middleware';
        $filePath = $middlewarePath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Middleware {$className} already exists.\n";
            exit(1);
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/middleware.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Middleware created: {$filePath}\n";
        
    } elseif ($makeType === 'migration') {
        $migrationName = $name;
        $timestamp = date('Y_m_d_His');
        $migrationPath = __DIR__ . '/database/migrations';
        
        // Convert name to snake_case
        $snakeName = strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $migrationName));
        $snakeName = str_replace(['-', ' '], '_', $snakeName);
        
        $fileName = $timestamp . '_' . $snakeName . '.php';
        $filePath = $migrationPath . '/' . $fileName;
        
        if (file_exists($filePath)) {
            echo "Error: Migration {$fileName} already exists.\n";
            exit(1);
        }
        
        // Try to extract table name from migration name
        $tableName = $snakeName;
        if (preg_match('/create_(.+)_table/', $snakeName, $matches)) {
            $tableName = $matches[1];
        } elseif (preg_match('/add_(.+)_to_(.+)_table/', $snakeName, $matches)) {
            $tableName = $matches[2];
        } elseif (preg_match('/drop_(.+)_from_(.+)_table/', $snakeName, $matches)) {
            $tableName = $matches[2];
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/migration.stub');
        $stub = str_replace('{{TABLE_NAME}}', $tableName, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Migration created: {$filePath}\n";
        
    } elseif ($makeType === 'request') {
        $className = $toClassName($name);
        $requestPath = __DIR__ . '/src/Http/Requests';
        $filePath = $requestPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Request {$className} already exists.\n";
            exit(1);
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/request.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Request created: {$filePath}\n";
        
    } elseif ($makeType === 'event') {
        $className = $toClassName($name);
        $eventPath = __DIR__ . '/src/Events';
        $filePath = $eventPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Event {$className} already exists.\n";
            exit(1);
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/event.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Event created: {$filePath}\n";
        
    } elseif ($makeType === 'listener') {
        $className = $toClassName($name);
        $listenerPath = __DIR__ . '/src/Events/Listeners';
        
        if (!is_dir($listenerPath)) {
            mkdir($listenerPath, 0755, true);
        }
        
        $filePath = $listenerPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Listener {$className} already exists.\n";
            exit(1);
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/listener.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        
        // Add event type hint if specified
        if (isset($options['event'])) {
            $eventClass = $toClassName($options['event']);
            $stub = str_replace('use IsekaiPHP\Events\Event;', "use IsekaiPHP\Events\Event;\nuse IsekaiPHP\Events\\{$eventClass};", $stub);
            $stub = str_replace('public function handle(Event $event, string $eventName): void', "public function handle({$eventClass} \$event, string \$eventName): void", $stub);
        }
        
        file_put_contents($filePath, $stub);
        echo "✓ Listener created: {$filePath}\n";
        
    } elseif ($makeType === 'seed') {
        $className = $toClassName($name);
        $seedPath = __DIR__ . '/database/seeds';
        
        if (!is_dir($seedPath)) {
            mkdir($seedPath, 0755, true);
        }
        
        $filePath = $seedPath . '/' . $className . '.php';
        
        if (file_exists($filePath)) {
            echo "Error: Seed {$className} already exists.\n";
            exit(1);
        }
        
        $stub = file_get_contents(__DIR__ . '/stubs/seed.stub');
        $stub = str_replace('{{CLASS_NAME}}', $className, $stub);
        
        file_put_contents($filePath, $stub);
        echo "✓ Seed created: {$filePath}\n";
        
    } else {
        echo "Error: Unknown make command: make:{$makeType}\n";
        echo "Available make commands: make:controller, make:model, make:middleware, make:migration, make:request, make:event, make:listener, make:seed\n";
        exit(1);
    }
} else {
    echo "Unknown command: {$command}\n";
    exit(1);
}

